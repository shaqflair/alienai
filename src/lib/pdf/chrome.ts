// src/lib/pdf/chrome.ts
import PDFDocument from "pdfkit";

export type PdfBrand = {
  clientName: string;
  logoBuf?: Buffer | null;
  brandColor: string; // #RRGGBB
  productName?: string; // e.g. "AlienAI"
};

export type PdfChromeOptions = {
  brand: PdfBrand;
  headerHeight?: number;
  footerHeight?: number;
  watermarkText?: string;

  footerLeftText?: (brand: PdfBrand, pageNo: number, totalPages?: number) => string;
  footerRightText?: (brand: PdfBrand, pageNo: number, totalPages?: number) => string;
};

export type PdfBounds = {
  left: number;
  right: number;
  top: number; // content top
  bottom: number; // content bottom (safe area)
  width: number;
  height: number;
};

function safeHexColor(x: unknown, fallback = "#E60000") {
  const s = String(x ?? "").trim();
  if (/^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(s)) return s;
  return fallback;
}

/**
 * âœ… REAL CTM reset at PAGE START
 * Must be called immediately after a page exists (init) or after doc.addPage().
 * This prevents mirrored/upside-down pages if a negative CTM leaked earlier.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function pageStartResetCTM(doc: any) {
  try {
    if (doc && typeof doc._write === "function") {
      // Force identity transform in the current content stream
      doc._ctm = [1, 0, 0, 1, 0, 0];
      doc._write("1 0 0 1 0 0 cm");
    }
  } catch {
    // ignore
  }
}

export function createPdfChrome(opts: PdfChromeOptions) {
  const headerHeight = Math.max(24, Math.min(120, opts.headerHeight ?? 42));
  const footerHeight = Math.max(18, Math.min(120, opts.footerHeight ?? 18));
  const watermarkText = String(opts.watermarkText ?? "").trim();

  const brand: PdfBrand = {
    clientName: String(opts.brand.clientName ?? "Client"),
    logoBuf: opts.brand.logoBuf ?? null,
    brandColor: safeHexColor(opts.brand.brandColor ?? "#E60000", "#E60000"),
    productName: String(opts.brand.productName ?? "AlienAI"),
  };

  let pageNo = 1;

  function bounds(doc: PDFDocument): PdfBounds {
    const left = doc.page.margins.left;
    const right = doc.page.width - doc.page.margins.right;

    const top = Math.max(doc.page.margins.top, headerHeight + 12);
    const bottom = doc.page.height - doc.page.margins.bottom - (footerHeight + 10);

    return {
      left,
      right,
      top,
      bottom,
      width: right - left,
      height: bottom - top,
    };
  }

  function drawHeader(doc: PDFDocument) {
    const left = doc.page.margins.left;
    const right = doc.page.width - doc.page.margins.right;

    // background band
    doc.save();
    doc.fillColor("#F5F5F5");
    doc.rect(0, 0, doc.page.width, headerHeight).fill();
    doc.restore();

    // underline accent
    doc.save();
    doc.fillColor(brand.brandColor);
    doc.rect(0, headerHeight - 2, doc.page.width, 2).fill();
    doc.restore();

    // client name
    doc.save();
    doc.fillColor("#222");
    doc.fontSize(11);
    doc.text(brand.clientName || "Client", left, 14, {
      width: right - left - 170,
      lineBreak: false,
      ellipsis: true,
    });
    doc.restore();

    // logo
    if (brand.logoBuf) {
      try {
        doc.save();
        doc.image(brand.logoBuf, right - 150, 7, { fit: [150, headerHeight - 14] });
        doc.restore();
      } catch {
        // ignore
      }
    }
  }

  function drawFooter(doc: PDFDocument) {
    const left = doc.page.margins.left;
    const right = doc.page.width - doc.page.margins.right;
    const footerY = doc.page.height - doc.page.margins.bottom + 6;

    const today = new Date().toISOString().slice(0, 10);
    const leftText =
      opts.footerLeftText?.(brand, pageNo) ??
      `Confidential â€“ ${brand.clientName} â€“ Generated by ${brand.productName} â€“ ${today}`;

    const rightText = opts.footerRightText?.(brand, pageNo) ?? `Page ${pageNo}`;

    // left
    doc.save();
    doc.fillColor("#666");
    doc.fontSize(8);
    doc.text(leftText, left, footerY, {
      width: Math.max(10, right - left - 90),
      align: "left",
      lineBreak: false,
      ellipsis: true,
    });
    doc.restore();

    // right
    doc.save();
    doc.fillColor("#666");
    doc.fontSize(8);
    doc.text(rightText, right - 90, footerY, {
      width: 90,
      align: "right",
      lineBreak: false,
      ellipsis: true,
    });
    doc.restore();
  }

  function drawWatermark(doc: PDFDocument) {
    if (!watermarkText) return;

    const pageW = doc.page.width;
    const pageH = doc.page.height;

    doc.save();
    doc.fillColor("#D9D9D9");
    doc.fontSize(64);

    doc.translate(pageW / 2, pageH / 2);
    doc.rotate(-35);

    doc.text(watermarkText, -pageW / 2, -20, {
      width: pageW,
      align: "center",
      lineBreak: false,
    });

    doc.restore();
  }

  /**
   * Apply chrome to the CURRENT page.
   * (Assumes pageStartResetCTM already ran for this page.)
   */
  function apply(doc: PDFDocument) {
    drawHeader(doc);
    drawFooter(doc);
    drawWatermark(doc);

    const b = bounds(doc);
    doc.y = b.top;
  }

  /**
   * âœ… The ONLY safe way to create a new page:
   * - increments page number
   * - adds page
   * - resets CTM at the start of the new page (prevents mirroring)
   * - applies chrome
   */
  function addPage(doc: PDFDocument) {
    pageNo += 1;
    doc.addPage();

    // ðŸ”¥ critical: reset CTM at the start of the new page
    pageStartResetCTM(doc);

    apply(doc);
  }

  /**
   * Call once right after doc is created (page 1 exists).
   * This ensures pageNo starts at 1 and chrome is applied.
   */
  function init(doc: PDFDocument) {
    pageNo = 1;

    // ðŸ”¥ critical: reset CTM at the start of page 1
    pageStartResetCTM(doc);

    apply(doc);
  }

  function getPageNumber() {
    return pageNo;
  }

  return { brand, init, apply, addPage, bounds, getPageNumber };
}
