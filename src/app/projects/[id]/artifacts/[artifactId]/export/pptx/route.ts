// src/app/projects/[id]/artifacts/[artifactId]/export/pptx/route.ts
import "server-only";

import PptxGenJS from "pptxgenjs";
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";

// ✅ REQUIRED: pptxgenjs + Buffer needs Node runtime
export const runtime = "nodejs";

/* -------------------------------- Utilities -------------------------------- */

function safeParam(x: unknown) {
  return typeof x === "string" ? x : "";
}

function safeHexColor(x: unknown, fallback = "#E60000") {
  const s = String(x ?? "").trim();
  if (/^#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})$/.test(s)) return s;
  return fallback;
}

function derivedStatus(a: any) {
  const s = String(a?.approval_status ?? "").toLowerCase();
  if (s === "approved") return "approved";
  if (s === "rejected") return "rejected";
  if (s === "changes_requested") return "changes_requested";
  if (s === "submitted") return "submitted";
  if (a?.approved_by) return "approved";
  if (a?.rejected_by) return "rejected";
  if (a?.is_locked) return "submitted";
  return "draft";
}

function watermarkTextFromStatus(status: string) {
  const s = String(status ?? "").toLowerCase();
  if (s === "approved") return "";
  if (s === "submitted") return "SUBMITTED";
  if (s === "changes_requested") return "CHANGES REQUESTED";
  if (s === "rejected") return "REJECTED";
  return "DRAFT";
}

function fmtDateOnly(x: string | null | undefined) {
  if (!x) return "";
  try {
    const d = new Date(x);
    if (Number.isNaN(d.getTime())) return String(x);
    return d.toISOString().slice(0, 10);
  } catch {
    return String(x);
  }
}

function stringifyFallback(x: any) {
  if (!x) return "";
  if (typeof x === "string") return x;
  try {
    return JSON.stringify(x, null, 2);
  } catch {
    return String(x);
  }
}

/* ---------------------------- Content extraction ---------------------------- */

type Section = {
  key: string;
  title: string;
  slide_template: string;
  content_json: any;
};

function getSectionsFromContentJson(content_json: any): Section[] {
  if (content_json && typeof content_json === "object" && Array.isArray((content_json as any).sections)) {
    return (content_json as any).sections.map((s: any, idx: number) => ({
      key: String(s?.key ?? `section_${idx + 1}`),
      title: String(s?.title ?? `Section ${idx + 1}`),
      slide_template: String(s?.slide_template ?? "bullets"),
      content_json: s?.content_json ?? {},
    }));
  }

  return [
    {
      key: "content",
      title: "Content",
      slide_template: "bullets",
      content_json: content_json ?? {},
    },
  ];
}

/* ----------------------------- Branding helpers ----------------------------- */

type Brand = {
  clientName: string;
  logoDataUri?: string;
  brandColor: string; // #RRGGBB
};

async function fetchLogoAsDataUri(url?: string | null): Promise<string | undefined> {
  const u = String(url ?? "").trim();
  if (!u) return undefined;

  try {
    const res = await fetch(u, { cache: "no-store" });
    if (!res.ok) return undefined;
    const ct = res.headers.get("content-type") || "image/png";
    const ab = await res.arrayBuffer();
    const b64 = Buffer.from(ab).toString("base64");
    return `data:${ct};base64,${b64}`;
  } catch {
    return undefined;
  }
}

function addWatermark(slide: any, text: string) {
  if (!text) return;
  slide.addText(text, {
    x: 0.5,
    y: 2.3,
    w: 12.33,
    h: 1.2,
    fontSize: 54,
    bold: true,
    color: "D9D9D9",
    align: "center",
    rotate: 315,
  });
}

function addClientHeader(slide: any, brand: Brand) {
  // ✅ Use string shape type to avoid module-format issues
  slide.addShape("rect", {
    x: 0,
    y: 0,
    w: 13.33,
    h: 0.55,
    fill: { color: "F5F5F5" },
    line: { color: "E5E5E5" },
  });

  slide.addShape("rect", {
    x: 0,
    y: 0.53,
    w: 13.33,
    h: 0.04,
    fill: { color: brand.brandColor.replace("#", "") },
    line: { color: brand.brandColor.replace("#", "") },
  });

  slide.addText(brand.clientName || "Client", {
    x: 0.55,
    y: 0.12,
    w: 9,
    h: 0.35,
    fontSize: 12,
    bold: true,
    color: "222222",
  });

  if (brand.logoDataUri) {
    slide.addImage({
      data: brand.logoDataUri,
      x: 11.6,
      y: 0.1,
      w: 1.55,
      h: 0.35,
    });
  }
}

function addFooter(slide: any, brand: Brand) {
  const today = new Date().toISOString().slice(0, 10);
  slide.addText(`Confidential – ${brand.clientName} – Generated by AlienAI – ${today}`, {
    x: 0.55,
    y: 7.25,
    w: 12.2,
    h: 0.25,
    fontSize: 9,
    color: "666666",
  });
}

/* ------------------------------- Approvals ---------------------------------- */

type ApprovalRow = {
  role: string;
  name: string;
  decision: "Approved" | "Rejected" | "Changes requested" | "Pending";
  date: string;
  comment: string;
};

async function buildApprovalRowsFromAudit(
  supabase: any,
  projectId: string,
  artifactId: string
): Promise<ApprovalRow[]> {
  const { data: approvers } = await supabase
    .from("project_approvers")
    .select("user_id, role")
    .eq("project_id", projectId)
    .eq("is_active", true);

  const approverList =
    approvers?.map((a: any) => ({
      user_id: String(a.user_id),
      role: String(a.role ?? "Approver"),
    })) ?? [];

  const ids = Array.from(new Set(approverList.map((a) => a.user_id).filter(Boolean)));
  const { data: profiles } = ids.length
    ? await supabase.from("profiles").select("user_id, full_name, email").in("user_id", ids)
    : ({ data: [] } as any);

  const byId = new Map<string, any>();
  for (const p of profiles ?? []) byId.set(String(p.user_id), p);

  const displayName = (uid: string, fallbackEmail?: string) => {
    const p = byId.get(uid);
    return (
      String(p?.full_name ?? "").trim() ||
      String(p?.email ?? "").trim() ||
      (fallbackEmail ? String(fallbackEmail).trim() : "") ||
      uid.slice(0, 8) + "…"
    );
  };

  const { data: auditRows } = await supabase
    .from("artifact_audit")
    .select("actor_user_id, actor_email, on_behalf_of_user_id, on_behalf_of_email, action, meta, created_at")
    .eq("project_id", projectId)
    .eq("artifact_id", artifactId)
    .order("created_at", { ascending: false })
    .limit(500);

  const latestByApprover = new Map<string, any>();
  for (const row of auditRows ?? []) {
    const effectiveUserId = String(row?.on_behalf_of_user_id ?? row?.actor_user_id ?? "");
    if (!effectiveUserId) continue;
    if (latestByApprover.has(effectiveUserId)) continue;

    const action = String(row?.action ?? "").toLowerCase();
    if (action.includes("approve") || action.includes("reject") || action.includes("change")) {
      latestByApprover.set(effectiveUserId, row);
    }
  }

  const mapDecision = (action: string): ApprovalRow["decision"] => {
    const a = String(action ?? "").toLowerCase();
    if (a.includes("approve")) return "Approved";
    if (a.includes("reject")) return "Rejected";
    if (a.includes("change")) return "Changes requested";
    return "Pending";
  };

  const commentFromMeta = (meta: any) => {
    const m = meta && typeof meta === "object" ? meta : {};
    return (
      String(m.reason ?? "").trim() ||
      String(m.comment ?? "").trim() ||
      String(m.note ?? "").trim() ||
      String(m.rejection_reason ?? "").trim() ||
      ""
    );
  };

  const rows: ApprovalRow[] = approverList.map((a) => {
    const ev = latestByApprover.get(a.user_id);
    return {
      role: a.role || "Approver",
      name: displayName(a.user_id, ev?.on_behalf_of_email || ev?.actor_email),
      decision: ev ? mapDecision(String(ev.action ?? "")) : "Pending",
      date: ev ? fmtDateOnly(ev.created_at ?? null) : "",
      comment: ev ? commentFromMeta(ev.meta) : "",
    };
  });

  if (rows.length === 0) {
    rows.push({
      role: "—",
      name: "No approvers configured",
      decision: "Pending",
      date: "",
      comment: "Add active approvers in Project Approvals.",
    });
  }

  return rows;
}

function addApprovalTableSlide(pptx: PptxGenJS, brand: Brand, watermark: string, rows: ApprovalRow[]) {
  const slide = pptx.addSlide();
  addClientHeader(slide, brand);

  slide.addText("Approvals", { x: 0.7, y: 0.85, w: 12, h: 0.6, fontSize: 22, bold: true });

  // Minimal table (safe)
  const headers = ["Role", "Approver", "Decision", "Date", "Comment"];
  const colWs = [2.2, 2.6, 1.6, 1.2, 5.2];
  const x0 = 0.7;
  let y = 1.65;
  const rowH = 0.45;

  // header
  {
    let x = x0;
    for (let i = 0; i < headers.length; i++) {
      slide.addShape("rect", {
        x,
        y,
        w: colWs[i],
        h: rowH,
        fill: { color: "F2F2F2" },
        line: { color: "CCCCCC" },
      });
      slide.addText(headers[i], {
        x: x + 0.08,
        y: y + 0.06,
        w: colWs[i] - 0.16,
        h: rowH - 0.12,
        fontSize: 11,
        bold: true,
        color: "222222",
      });
      x += colWs[i];
    }
    y += rowH;
  }

  for (const r of (rows ?? []).slice(0, 12)) {
    let x = x0;
    const vals = [r.role, r.name, r.decision, r.date, r.comment];
    for (let i = 0; i < vals.length; i++) {
      slide.addShape("rect", {
        x,
        y,
        w: colWs[i],
        h: rowH,
        fill: { color: "FFFFFF" },
        line: { color: "E5E5E5" },
      });
      slide.addText(vals[i] || "—", {
        x: x + 0.08,
        y: y + 0.06,
        w: colWs[i] - 0.16,
        h: rowH - 0.12,
        fontSize: 10,
        color: "222222",
        wrap: true,
        valign: "top",
      });
      x += colWs[i];
    }
    y += rowH;
    if (y > 6.8) break;
  }

  addFooter(slide, brand);
  addWatermark(slide, watermark);
}

/* ---------------------------------- GET ------------------------------------ */

export async function GET(
  req: Request,
  ctx: { params: Promise<{ id: string; artifactId: string }> }
) {
  try {
    // ✅ FIX: Next 15/16 dynamic route params
    const { id, artifactId } = await ctx.params;
    const projectId = safeParam(id).trim();
    const aid = safeParam(artifactId).trim();

    if (!projectId || !aid) {
      return NextResponse.json({ error: "Missing params" }, { status: 400 });
    }

    const supabase = await createClient();

    const { data: auth } = await supabase.auth.getUser();
    if (!auth?.user) return NextResponse.redirect(new URL("/login", req.url));

    // Membership check
    const { data: mem, error: memErr } = await supabase
      .from("project_members")
      .select("role")
      .eq("project_id", projectId)
      .eq("user_id", auth.user.id)
      .maybeSingle();

    if (memErr) return NextResponse.json({ error: memErr.message }, { status: 500 });
    if (!mem) return NextResponse.json({ error: "Not a project member" }, { status: 403 });

    // Branding
    const { data: project, error: projErr } = await supabase
      .from("projects")
      .select("title, client_name, client_logo_url, brand_primary_color")
      .eq("id", projectId)
      .maybeSingle();
    if (projErr) console.warn("[projects.select]", projErr.message);

    const brand: Brand = {
      clientName:
        String(project?.client_name ?? "").trim() ||
        String(project?.title ?? "").trim() ||
        "Client",
      brandColor: safeHexColor(project?.brand_primary_color, "#E60000"),
      logoDataUri: await fetchLogoAsDataUri(project?.client_logo_url ?? null),
    };

    // Artifact
    const { data: artifact, error: artErr } = await supabase
      .from("artifacts")
      .select("id, project_id, title, content_json, approval_status, approved_by, rejected_by, is_locked, version")
      .eq("id", aid)
      .eq("project_id", projectId)
      .maybeSingle();

    if (artErr) return NextResponse.json({ error: artErr.message }, { status: 500 });
    if (!artifact) return NextResponse.json({ error: "Artifact not found" }, { status: 404 });

    const status = derivedStatus(artifact);
    const watermark = watermarkTextFromStatus(status);

    const pptx = new PptxGenJS();
    pptx.layout = "LAYOUT_WIDE";
    pptx.author = "AlienAI";
    pptx.company = "AlienAI";
    pptx.title = String(artifact.title ?? "Executive Pack");

    const sections = getSectionsFromContentJson((artifact as any).content_json);

    // Cover
    {
      const slide = pptx.addSlide();
      addClientHeader(slide, brand);

      slide.addText(String(artifact.title ?? "Executive Pack"), {
        x: 0.7,
        y: 1.7,
        w: 12,
        h: 1,
        fontSize: 34,
        bold: true,
        color: "222222",
      });

      slide.addText(
        `Status: ${status.toUpperCase()}   Version: ${String((artifact as any).version ?? "—")}`,
        { x: 0.7, y: 2.5, w: 12, h: 0.5, fontSize: 14, color: "666666" }
      );

      addFooter(slide, brand);
      addWatermark(slide, watermark);
    }

    // Sections
    for (const s of sections) {
      const slide = pptx.addSlide();
      addClientHeader(slide, brand);

      slide.addText(s.title, {
        x: 0.7,
        y: 0.9,
        w: 12,
        h: 0.6,
        fontSize: 22,
        bold: true,
        color: "222222",
      });

      slide.addText(stringifyFallback(s.content_json) || "—", {
        x: 0.8,
        y: 1.7,
        w: 11.8,
        h: 5.3,
        fontSize: 14,
        wrap: true,
        valign: "top",
        color: "222222",
      });

      addFooter(slide, brand);
      addWatermark(slide, watermark);
    }

    // Approvals
    const approvalRows = await buildApprovalRowsFromAudit(supabase, projectId, aid);
    addApprovalTableSlide(pptx, brand, watermark, approvalRows);

    const fileNameBase = String(artifact.title ?? "Executive-Pack")
      .replace(/[^\w\-]+/g, "-")
      .replace(/\-+/g, "-")
      .replace(/^\-|\-$/g, "");

    const fileName = `${fileNameBase || "Executive-Pack"}-${status.toUpperCase()}.pptx`;

    // ✅ Node runtime output
    const buffer = (await pptx.write("nodebuffer")) as Buffer;

    return new NextResponse(buffer, {
      status: 200,
      headers: {
        "Content-Type": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        "Content-Disposition": `attachment; filename="${fileName}"`,
        "Cache-Control": "no-store",
      },
    });
  } catch (e: any) {
    // ✅ This makes your 500 actionable
    return NextResponse.json(
      { error: e?.message || String(e), stack: e?.stack || null },
      { status: 500 }
    );
  }
}
